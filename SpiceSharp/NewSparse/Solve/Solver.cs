using System;
using System.Diagnostics;
using SpiceSharp.NewSparse.Solve;

namespace SpiceSharp.NewSparse
{
    /// <summary>
    /// Template for a solver
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public abstract class Solver<T> where T : IFormattable
    {
        /// <summary>
        /// Number of fill-ins in the matrix generated by the solver
        /// </summary>
        public int Fillins { get; private set; }

        /// <summary>
        /// Gets or sets a flag that reordering is required
        /// </summary>
        public bool NeedsReordering { get; set; }

        /// <summary>
        /// Relative threshold for pivots
        /// </summary>
        public double RelativePivotThreshold { get; set; } = 1e-3;

        /// <summary>
        /// Absolute threshold for pivots
        /// </summary>
        public double AbsolutePivotThreshold { get; set; } = 0.0;

        protected Stopwatch swPivot = new Stopwatch();
        protected Stopwatch swExchange = new Stopwatch();
        protected Stopwatch swEliminate = new Stopwatch();

        /// <summary>
        /// Gets the matrix to work on
        /// </summary>
        public Matrix<T> Matrix { get; }

        /// <summary>
        /// Gets the right-hand side
        /// </summary>
        public Vector<T> Rhs
        {
            get
            {
                if (rhs.Length != Matrix.Size + 1)
                    rhs = new Vector<T>(Matrix.Size + 1);
                return rhs;
            }
        }
        Vector<T> rhs;

        /// <summary>
        /// Gets the pivot strategy used
        /// </summary>
        public PivotStrategy<T> Strategy { get; }

        /// <summary>
        /// Constructor
        /// </summary>
        public Solver(PivotStrategy<T> strategy)
        {
            Matrix = new Matrix<T>();
            rhs = new Vector<T>(1);
            NeedsReordering = true;
            Strategy = strategy;
        }

        /// <summary>
        /// Solve
        /// </summary>
        /// <param name="solution">Solution vector</param>
        public abstract void Solve(Vector<T> solution);

        /// <summary>
        /// Solve the transposed problem
        /// </summary>
        /// <param name="solution">Solution vector</param>
        public abstract void SolveTransposed(Vector<T> solution);

        /// <summary>
        /// Factor the matrix
        /// </summary>
        public abstract void Factor();

        /// <summary>
        /// Order and factor the matrix
        /// </summary>
        public abstract void OrderAndFactor();

        /// <summary>
        /// Move a chosen pivot to (step, step)
        /// </summary>
        /// <param name="pivot">Pivot</param>
        /// <param name="step">Step</param>
        protected void MovePivot(Element<T> pivot, int step)
        {
            swPivot.Start();
            Strategy.MovePivot(Matrix, Rhs, pivot, step);
            swPivot.Stop();

            swExchange.Start();
            // Move the pivot in the matrix
            int row = pivot.Row;
            int column = pivot.Column;
            if (row != step)
            {
                Matrix.SwapRows(row, step);

                // Swap Right-hand side vector elements
                var tmp = Rhs[step];
                Rhs[step] = Rhs[row];
                Rhs[row] = tmp;
            }
            if (column != step)
                Matrix.SwapColumns(column, step);
            swExchange.Stop();

            swPivot.Start();
            Strategy.Update(Matrix, pivot, step);
            swPivot.Stop();
        }

        /// <summary>
        /// Create a fillin
        /// </summary>
        /// <param name="row">Row</param>
        /// <param name="column">Column</param>
        /// <returns></returns>
        protected virtual Element<T> CreateFillin(int row, int column)
        {
            var result = Matrix.GetElement(row, column);
            Fillins++;
            return result;
        }
    }
}
